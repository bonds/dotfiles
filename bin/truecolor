#!/usr/bin/env cabal
{- cabal:
build-depends:
    base
  , rio
  , optparse-applicative
-}

-- Copyright (c) 2021 Scott Bonds <scott@ggr.com>
-- ISC License, see https://en.wikipedia.org/wiki/ISC_license

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE BinaryLiterals #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DoAndIfThenElse #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE PatternGuards #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE ViewPatterns #-}

{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Wcompat #-}
{-# OPTIONS_GHC -Widentities #-}
{-# OPTIONS_GHC -Wincomplete-record-updates #-}
{-# OPTIONS_GHC -Wincomplete-uni-patterns #-}
{-# OPTIONS_GHC -Wpartial-fields #-}
{-# OPTIONS_GHC -Wredundant-constraints #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

{-# HLINT ignore "Unused LANGUAGE pragma" #-}

module Main where

import RIO
import RIO.ByteString as B
import RIO.List as L
import RIO.Process as P
import RIO.Text as T
import Options.Applicative as O
import System.Environment as E

main :: IO ()
main = do
    args <- withProgName "truecolor" $ execParser opts
    wi <- width' (width args)

    -- need to wait for a little bit, or the piped stdin might not be ready
    -- otherwise we could have used: gotPipedMessage <- RIO.hReady stdin
    gotPipedMessage <- hWaitForInput stdin 100
    
    mmsg' <- if gotPipedMessage then do
                 Just . decodeUtf8Lenient <$> B.getContents
             else 
                 return $ message args
    B.putStr $ encodeUtf8 $ colorit wi mmsg'
  where
    colorit :: Int -> Maybe Text -> Text
    colorit wid mmess =
        case mmess of
            Just mess -> rainbowize mess
            Nothing   -> rainbowize wid

data Options = Options
  { width :: Maybe Int
  , message :: Maybe Text
  }

options :: Parser Options
options = Options
      <$> optional (option auto
          ( long "width"
         <> short 'w'
         <> metavar "WIDTH"
         <> help "number of characters to print, defaults to the width of the terminal" ))
      <*> optional (argument str
          ( help "string to rainbowize"
         <> metavar "STRING" ))

opts :: ParserInfo Options
opts = info (options <**> helper)
  ( fullDesc
  <> header (T.unpack $ "truecolor - print all the colors of the " <> rainbowize ("rainbow" :: Text) <> ".")
  <> progDesc "" )
-- BUG: this wraps the 'rainbow' word to the next line, my guess is that
-- the color code are interpetted as characters and Options.Applicative is 
-- counting the width wrong

-- |Get the width of the current terminal in columns 
-- or failing that, assume its 80 columns wide.
-- BTW using 'stty size' instead of 'tput cols' because 'tput' reports
-- the wrong size under certain cirmustances
width' :: Maybe Int -> IO Int
width' widthParam = do
    (cols, _) <- readProcess_ "stty size | awk '{print $2}'"
    let widthFromTerminal = fromMaybe 80 (readMaybe $ T.unpack $ decodeUtf8Lenient $ B.toStrict cols :: Maybe Int)
    return $ fromMaybe widthFromTerminal widthParam

class Rainbowize a where
    -- |Generate some text that's colored like a rainbow.
    rainbowize :: a -> Text

instance Rainbowize Int where
    -- |Generate a rainbow colored block N characters wide.
    rainbowize le =
        T.concat
      $ L.map (colorize Background " ") (colorsAcrossWidth' le)

instance Rainbowize Text where
    -- |Color an input string like a rainbow.
    rainbowize txt = 
        T.concat
      $ L.zipWith (colorize Foreground) (chunksOf 1 txt) (colorsAcrossWidth' le) ++ ["\n"]
      where
        le = T.length txt

colorize :: Layer -> Text -> (Int, Int, Int) -> Text
colorize lc message (cr,cg,cb) =
      escapeCode Start <> layerCode lc <> cformatCode RGB
   <> T.pack (show cr) <> ";" <> T.pack (show cg) <> ";" <> T.pack (show cb) 
   <> escapeCode End
   <> message
-- <> escapeCode Start <> escapeCode ClearFormatting <> escapeCode End

data Layer = Foreground | Background 

layerCode :: Layer -> Text
layerCode Foreground = "38;"
layerCode Background = "48;"

data ColorFormat = RGB

cformatCode :: ColorFormat -> Text
cformatCode RGB = "2;"

data Escape = Start | End | ClearFormatting 

escapeCode :: Escape -> Text
escapeCode Start = "\x1b["
escapeCode End = "m"
escapeCode ClearFormatting = "0"

-- |Given an input angle between 0 and 360, output a single RGB color from a rainbow 
-- that's been smeared across 360 degrees, see also 
-- https://www.instructables.com/How-to-Make-Proper-Rainbow-and-Random-Colors-With-/
angleToColor :: Float -> (Int, Int, Int)
angleToColor input
    | angle < 60  = (255, round (angle * 4.25 - 0.01), 0)
    | angle < 120 = (round ((120 - angle) * 4.25 - 0.01), 255, 0)
    | angle < 180 = (0, 255, round ((angle - 120) * 4.25 - 0.01))
    | angle < 240 = (0, round ((240 - angle) * 4.25 - 0.01), 255)
    | angle < 300 = (round ((angle - 240) * 4.25 - 0.01), 0, 255)
    | otherwise   = (255, 0, round ((360 - angle) * 4.25 - 0.01))
  where
    angle = input/360*limit
    limit = 275

colorsAcrossWidth' :: Int -> [(Int, Int, Int)]
colorsAcrossWidth' width = 
    fmap (colorAtPoint width keyColors) [0..width-1]
  where
    keyColors = [red, orange, yellow, green, blue, indigo, violet]

    colorAtPoint :: Int -> [(Int, Int, Int)] -> Int -> (Int, Int, Int)
    colorAtPoint wi cs pt
        | pt < wi `div` ((L.length keyColors)-1) = 
            interpolateColors 
                (100*pt `div` (wi `div` ((L.length keyColors)-1)))
                (case L.headMaybe (L.take 2 cs) of
                    Just color -> color
                    Nothing -> (155,155,155))
                (case L.lastMaybe (L.take 2 cs) of
                    Just color -> color
                    Nothing -> (255,255,255))
        | otherwise = 
            colorAtPoint
                wi
                (case (L.tailMaybe cs) of
                    Just cs' -> cs'
                    Nothing -> [])
                (pt - wi `div` ((L.length keyColors)-1))

-- |Generate an RGB rainbow using the specified number of points.
colorsAcrossWidth :: Int -> [(Int, Int, Int)]
colorsAcrossWidth wi =
    case L.splitAt (round (fromIntegral wi * splitPoint :: Float))
       $ il wi of (as, bs) -> bs ++ as
  where
    il wid = L.map angleToColor [0, 360 / (fromIntegral wid-1 :: Float)..360]
    splitPoint = 1.0

red :: (Int, Int, Int)
red = (255, 0, 0)

orange :: (Int, Int, Int)
orange = (255, 165, 0)

yellow :: (Int, Int, Int)
yellow = (255, 255, 0)

green :: (Int, Int, Int)
green = (0, 255, 0)

blue :: (Int, Int, Int)
blue = (0, 0, 255)

indigo :: (Int, Int, Int)
indigo = (75, 0, 130)

violet :: (Int, Int, Int)
violet = (238, 130, 238)

interpolateColors :: Int -> (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
interpolateColors perc (ra, ga, ba) (rb, gb, bb) =
    ((ic perc ra rb), (ic perc ga gb), (ic perc ba bb))
  where
    ic :: Int -> Int -> Int -> Int
    ic pe ca cb = ca+(cb-ca)*pe `div` 100